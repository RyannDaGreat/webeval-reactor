<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizing Derivatives with White Noise Texture</title>
    <style>
        body { margin: 0; overflow: hidden; display: flex; flex-direction: column; align-items: center; height: 100vh; }
        canvas { width: 100vw; height: 90vh; }
        #controls { width: 100%; display: flex; justify-content: center; align-items: center; height: 10vh; }
        .slider { width: 80%; }
    </style>
</head>
<body>
    <div id="controls">
        <input type="range" class="slider" id="brightnessSlider" min="0.1" max="10" step="0.1" value="1">
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight * 0.9); // Adjust for control panel
            document.body.insertBefore(renderer.domElement, document.getElementById('controls'));

            // Create white noise texture
            const noiseSize = 128;
            const data = new Uint8Array(noiseSize * noiseSize * 3);
            for (let i = 0; i < data.length; i += 3) {
                const val = Math.floor(Math.random() * 256);
                data[i] = data[i + 1] = data[i + 2] = val;
            }
            const texture = new THREE.DataTexture(data, noiseSize, noiseSize, THREE.RGBFormat);
            texture.needsUpdate = true;

            // Geometry and material setup
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    uniform float brightness;
                    uniform sampler2D noiseTexture;
                    void main() {
                        vec2 dx = dFdx(vUv) * brightness;
                        vec2 dy = dFdy(vUv) * brightness;
                        vec3 noise = texture2D(noiseTexture, vUv).rgb;
                        gl_FragColor = vec4(abs(dx.x), abs(dy.y), noise.b, 1.0);
                    }
                `,
                uniforms: {
                    brightness: { value: 1.0 },
                    noiseTexture: { value: texture }
                }
            });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            camera.position.z = 5;

            function animate() {
                requestAnimationFrame(animate);
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
                renderer.render(scene, camera);
            }
            animate();

            // Slider functionality
            let brightnessSlider = document.getElementById('brightnessSlider');
            brightnessSlider.addEventListener('input', function () {
                material.uniforms.brightness.value = parseFloat(this.value);
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / (window.innerHeight * 0.9);
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight * 0.9);
            });
        });
    </script>
</body>
</html>
