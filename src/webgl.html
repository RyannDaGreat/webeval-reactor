<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizing Derivatives with White Noise Canvas Texture</title>
    <style>
        body { margin: 0; overflow: hidden; display: flex; flex-direction: column; align-items: center; height: 100vh; }
        canvas { width: 100vw; height: 90vh; }
        #controls { width: 100%; display: flex; justify-content: center; align-items: center; height: 10vh; }
        .slider { width: 80%; }
    </style>
</head>
<body>
    <div id="controls">
        <input type="range" class="slider" id="brightnessSlider" min="0.1" max="100" step="0.1" value="1">
    </div>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(24, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer();
            renderer.setSize(window.innerWidth, window.innerHeight * 0.9); // Adjust for control panel
            document.body.insertBefore(renderer.domElement, document.getElementById('controls'));

            // Create a canvas and draw white noise
            const noiseCanvas = document.createElement('canvas');
            const noiseContext = noiseCanvas.getContext('2d');
            noiseCanvas.width = noiseCanvas.height = 128;
            const imageData = noiseContext.createImageData(128, 128);
            for (let i = 0; i < imageData.data.length; i += 4) {
                const color = Math.random() * 255;
                imageData.data[i] = color; // Red
                imageData.data[i + 1] = color; // Green
                imageData.data[i + 2] = color; // Blue
                imageData.data[i + 3] = 255;   // Alpha
            }
            noiseContext.putImageData(imageData, 0, 0);
            const texture = new THREE.CanvasTexture(noiseCanvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;

            // Geometry and material setup
            const geometry = new THREE.BoxGeometry();
            const material = new THREE.ShaderMaterial({
                vertexShader: `
                    varying vec2 vUv;
                    void main() {
                        vUv = uv;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    uniform float brightness;
                    uniform sampler2D noiseTexture;
                    void main() {
                        vec2 dx = dFdx(vUv) * brightness;
                        vec2 dy = dFdy(vUv) * brightness;
                        float noiseValue = texture2D(noiseTexture, vUv).b; // Use the blue channel for noise
                        gl_FragColor = vec4(abs(dx.x), abs(dy.y), noiseValue, 1.0);
                    }
                `,
                uniforms: {
                    brightness: { value: 1.0 },
                    noiseTexture: { value: texture }
                }
            });
            const cube = new THREE.Mesh(geometry, material);
            scene.add(cube);

            camera.position.z = 5;

            function animate() {
                requestAnimationFrame(animate);
                cube.rotation.x += 0.01;
                cube.rotation.y += 0.01;
                renderer.render(scene, camera);
            }
            animate();

            // Slider functionality
            let brightnessSlider = document.getElementById('brightnessSlider');
            brightnessSlider.addEventListener('input', function () {
                material.uniforms.brightness.value = parseFloat(this.value);
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / (window.innerHeight * 0.9);
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight * 0.9);
            });
        });
    </script>
</body>
</html>
